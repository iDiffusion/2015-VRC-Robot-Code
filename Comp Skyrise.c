#pragma config(Sensor, in1,    lineTracker,    sensorLineFollower)
#pragma config(Sensor, dgtl1,  clawPiston,     sensorDigitalOut)
#pragma config(Sensor, dgtl2,  flippyPiston,   sensorDigitalOut)
#pragma config(Motor,  port2,           frontLeftMotor, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           backLeftMotor, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           frontRightMotor, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,           backRightMotor, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightLift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           conveyorMotor, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/*-------------------------------------------------------------------------------------------------
Project Title: Drive Skyrise V4 of Robot
Creator: Ikaika
Team Number: 916A
Game: Skyrise
Section: Competition
Driver Description:
-)	Holonomic Drive (X Driver)
-)	Tank/Arcade Driver Control
-)	Danny Lift
-)	Piston Skyrise Loader
-)	Cube Conveyor Belt

////////////////////////////////////////////////
/* 0 is the startup screen Drivers Skills     */
/* 1 is the Programming Skills                */
/* 2 is the Red Left Program           	      */
/* 3 is the Red Right Program		      */
/* 4 is the Blue Left Program                 */
/* 5 is the Blue Right Program		      */
////////////////////////////////////////////////
/* 0 is Tank Driver Control		      */
/* 1 is Arcade Driver Control		      */
////////////////////////////////////////////////

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++

ROBOT CONFIGURATION
NOTES:
1)	Driver Control:
a.		Tank Control:
I.			Ch2 controls right drive
II.  			Ch3 controls left drive.
b.		Arcade Control:
I.			Ch1 controls Point Turning Right And Left
II.  			Ch3 controls Foward And Backward movement
III.			Ch4 controls Strafing Left And Right
2)	Lift Control
a.		Btn5U moves the lift up
b.		Btn5D moves the lift up
3)	Claw Control
a. 		Btn6U closes the claw
b.		Btn6D opens the claw
4)	Conveyor Belt Control3
a.		Btn7U rotates belt upward
b.		Btn7D totates belt downward
5)	Extra Driver Control
a.		Btn8U moves forward slowly
b.		Btn8L strafes left slowly
c.		Btn8R strafes right slowly
d.		Btn8D moves backward slowly

[I/O Port]          [Name]                   [Type]                [Description]
------------------------------------------------------------------------------------------
Motor Port 2        frontRightMotor          VEX 393 Motor         Front Right Motor
Motor Port 3        backRightMotor           VEX 393 Motor         Back Right Motor
Motor Port 4        frontLeftMotor           VEX 393 Motor         Front Left Motor
Motor Port 5        backLeftMotor            VEX 393 Motor         Back Left Motor
Motor Port 6        leftLift                 VEX 393 Motor         Left Lift Motor (Dual Motors)
Motor Port 7        rightLift                VEX 393 Motor         Right Lift Motor (Dual Motors)
Motor Port 8	    conveyorMotor	     VEX 393 Motor	   Conveyor Belt Motor
///////////////////////////////////////////////////////////////////////////////////////////
Analog Port 1	    lineTracker		     Line Follower	   Track and follow the white line
Digital Port 1	    clawPiston		     Pnuematic Solenoid	   Used to open and close claw
Digital Port 2	    flippyPiston	     Pnuematic Solenoid    Used to flip out the claw
///////////////////////////////////////////////////////////////////////////////////////////
UART2		    Vex LCD Display	     UART1		   Vex LCD Display
I2C_1       	    frontLeftMotor           IEM         	   Measure how much the frontLeftMotor rotates
I2C_2		    backLeftMotor            IEM         	   Measure how much the backLeftMotor rotates
I2C_3		    leftLift		     IEM         	   Measure left lift encoder counts
I2C_4		    rightLift		     IEM         	   Measure right lift encoder counts
I2C_5		    backRightMotor	     IEM		   Measure how much the backRightMotor rotates
I2C_6		    frontRightMotor	     IEM		   Measure how much the frontRightMotor rotates
----------------------------------------------------------------------------------------------------*/

/*++++++++++++++++++++++++++++++++++++++++++++|Variables|++++++++++++++++++++++++++++++++++++++++++++++*/
#define deadzone 	16	//Establish a deadzone for the controller
int Y1 = 0, X1 = 0, X2 = 0;//Establish the speed of the Drive Train (arcade only)
//--------------------------------------------------------------------------------------
const short leftButton = 1;		//value for Left button on LCD Display
const short centerButton = 2;	//value for Center button on LCD Display
const short rightButton = 4;	//value for Right button on LCD Display
//-------------------------------------------------------------------------------------
int count = 0;//Declare count variable to keep select the autonomous program desired
int selectProgram = 0;// Declare selectProgram to keep track of which program to initiate
int driverC = 0; //Declare driverC variable to keep trak of the driver control program selected
//--------------------------------------------------------------------------------------
int greyTile = 420;//store the value of the grey tile
int whiteTape = 320;//store the value of the white tape
int coloredTile = 450;//store the value of the colored tile
int maxLiftLimit = 8500;//change this to determine the max limit the lift can go
int tracker = 0;//stores the value of the line tracker
/*++++++++++++++++++++++++++++++++++++++++++++|Functions|+++++++++++++++++++++++++++++++++++++++++++++++++*/
void waitForPress()//wait for a button on the LCD display to be pressed
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease()//wait for a button on the LCD display to be released
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
void batteryPower()//Display Battery power during Autonomous and preAuton
{
	string mainBattery, backupBattery; //Make the battery power titles
	wait1Msec(1);
	while(nLCDButtons == 0)
	{
		clearLCDLine(1);  // Clear line 2 (1) of the LCD
		wait1Msec(10);//Short delay for the LCD refresh rate

		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayLCDString(1, 0, mainBattery);//Display the Primary battery level

		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayLCDString(1, 11, backupBattery);//Display the Backup battery level

		wait1Msec(100);//Short delay for the LCD refresh rate
	}
	wait1Msec(5);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
void stopAllMotors()//Stop all motors
{
	motor[frontLeftMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	motor[leftLift] = 0;
	motor[rightLift] = 0;
	SensorValue[clawPiston] = 0;
	wait1Msec(100);
}
void resetEncoders()//Reset all encoders
{
	nMotorEncoder[frontLeftMotor] = 0;
	nMotorEncoder[frontRightMotor] = 0;
	nMotorEncoder[backLeftMotor] = 0;
	nMotorEncoder[backRightMotor] = 0;
	nMotorEncoder[leftLift] = 0;
	nMotorEncoder[rightLift] = 0;
}
//++++++++++++++++++++++++++++++++++++++++++|Autonomous Call Functions|+++++++++++++++++++++++++++++++++++++++++//
void strafeRight(int speed, int duration)
{
	//Speed - How fast the robot moves
	//Duration - How long the robot moves

	motor[frontLeftMotor] = speed;
	motor[frontRightMotor] = -speed;
	motor[backLeftMotor] = -speed;
	motor[backRightMotor] = speed;
	wait1Msec(duration);

	motor[frontLeftMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	wait1Msec(100);
}

void strafeLeft(int speed, int duration)
{
	//Speed - How fast the robot moves
	//Duration - How long the robot moves

	motor[frontLeftMotor] = -speed;
	motor[frontRightMotor] = speed;
	motor[backLeftMotor] = speed;
	motor[backRightMotor] = -speed;
	wait1Msec(duration);

	motor[frontLeftMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	wait1Msec(100);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void driveFoward(int speed, int duration)
{
	//Speed - How fast the robot moves
	//Duration - How long the robot moves

	motor[frontLeftMotor] = speed;
	motor[frontRightMotor] = speed;
	motor[backLeftMotor] = speed;
	motor[backRightMotor] = speed;
	wait1Msec(duration);

	motor[frontLeftMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	wait1Msec(100);
}

void driveBackward(int speed, int duration)
{
	//Speed - How fast the robot moves
	//Duration - How long the robot moves

	motor[frontLeftMotor] = -speed;
	motor[frontRightMotor] = -speed;
	motor[backLeftMotor] = -speed;
	motor[backRightMotor] = -speed;
	wait1Msec(duration);

	motor[frontLeftMotor] = 0;
	motor[backLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	wait1Msec(100);
}

/*+++++++++++++++++++++++++++++++++++++++++++++|Other Task|+++++++++++++++++++++++++++++++++++++++++++++++++++*/
task batteryPowerD()//Display Battery Power
{
	string mainBattery, backupBattery; //Make the battery power titles
	while(true)
	{
		clearLCDLine(0);  // Clear Line 1 (0) of the LCD
		displayLCDCenteredString(0, "Team 916A");

		clearLCDLine(1);  // Clear line 2 (1) of the LCD
		wait1Msec(10);//Short delay for the LCD refresh rate

		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayLCDString(1, 1, mainBattery);//Display the Primary battery level

		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayLCDString(1, 9, backupBattery);//Display the Backup battery level

		wait1Msec(100);//Short delay for the LCD refresh rate
	}
}
task updateValues()//contantly updating local changing values
{
	while(true)//update local values w/ sensorvalues
	{
		tracker = SensorValue[lineTracker];
		wait1Msec(100);
	}
}
/*+++++++++++++++++++++++++++++++++++++++++++++|Pre Auton|+++++++++++++++++++++++++++++++++++++++++++++++++++*/

void pre_auton()
{
	startTask(updateValues);//used to constantly update local variables
	bLCDBacklight = true;//Turn LCD ON
	clearLCDLine(0);//Clear LCD Top Line
	clearLCDLine(1);//Clear LCD Bottom Line
	while(count < 2)//Loop while a program is not selected
	{
		switch(selectProgram)//Switch case that allows the user to choose from 6 different programs
		{
		case 0://Display Driver Skills
			if(count == 0)
			{
				displayLCDCenteredString(0, "Driver Skills");
				displayLCDCenteredString(1, "<Red       Blue>");
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectProgram = 3;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectProgram = 4;
				}
			}
			else if (count == 1)
			{
				displayLCDCenteredString(0,"Select Driver");
				batteryPower();
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 2;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
			}
			break;

		case 1://Programming skills
			if(count == 0)
			{
				displayLCDCenteredString(0, "Program'n Skills");
				displayLCDCenteredString(1, "Red Left");
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectProgram = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectProgram = 2;
				}
			}
			else if (count == 1)
			{
				displayLCDCenteredString(0,"Select P-Skills");
				batteryPower();
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 2;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
			}
			break;
			///////////////////////////////////////////////////////////////////////////////////
		case 2://Red Left Autonomous
			if(count == 0)
			{
				displayLCDCenteredString(0, "Red Left Auton");
				displayLCDCenteredString(1, "## Points");
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectProgram = 1;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectProgram = 3;
				}
			}
			else if (count == 1)
			{
				displayLCDCenteredString(0,"Select RL");
				batteryPower();
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 2;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
			}
			break;

		case 3://Red Right Autonomous
			if(count == 0)
			{
				displayLCDCenteredString(0, "Red Right Auton");
				displayLCDCenteredString(1, "## Points");
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectProgram = 2;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectProgram = 0;
				}
			}
			else if (count == 1)
			{
				displayLCDCenteredString(0,"Select RR");
				batteryPower();
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 2;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
			}
			break;

		case 4://Blue Left Autonomous
			if(count == 0)
			{
				displayLCDCenteredString(0, "Blue Left Auton");
				displayLCDCenteredString(1, "## Points");
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectProgram = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectProgram = 5;
				}
			}else if (count == 1)
			{
				displayLCDCenteredString(0,"Select BL");
				batteryPower();
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 2;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
			}
			break;
		case 5://Blue Right Autonomous
			if(count == 0)
			{
				displayLCDCenteredString(0, "Blue Right Auton");
				displayLCDCenteredString(1, "## Points");
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectProgram = 4;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectProgram = 6;
				}
			}
			else if (count == 1)
			{
				displayLCDCenteredString(0,"Select BR");
				batteryPower();
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 2;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
			}
			break;
			/////////////////////////////////////////////////////
		case 6://Alternate Autonomous
			if(count == 0)
			{
				displayLCDCenteredString(0, "Alternate");
				displayLCDCenteredString(1, "1 Points");
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					selectProgram = 5;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					selectProgram = 0;
				}
			}
			else if (count == 1)
			{
				displayLCDCenteredString(0,"Select Alt");
				batteryPower();
				waitForPress();
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 2;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
			}
			break;
			/////////////////////////////////////////////////////
		default:
			selectProgram = 0;
			break;
		}
	}
	while(nLCDButtons != centerButton)
	{
		switch(driverC)
		{
		case 0:
			displayLCDCenteredString(0, "Confirm");
			displayLCDCenteredString(1, "Tank Control");
			waitForPress();
			if(nLCDButtons == leftButton || nLCDButtons == rightButton)
			{
				waitForRelease();
				driverC = 1;
			}
			break;
		case 1:
			displayLCDCenteredString(0, "Confirm");
			displayLCDCenteredString(1, "Arcade Control");
			waitForPress();
			if(nLCDButtons == leftButton || nLCDButtons == rightButton)
			{
				waitForRelease();
				driverC = 0;
			}
			break;
		}
	}
}
task autonomous()
{
	clearLCDLine(0);//Clear LCD top line
	clearLCDLine(1);//Clear LCD bottom line
	resetEncoders();//Reset all encoders before starting Autonomous
	switch(selectProgram)//Switch Case that actually runs the user choice
	{
	case 0://If selectProgram = 0, run the code allStop
		displayLCDCenteredString(0, "Drivers Skills");
		displayLCDCenteredString(1, "is ready to run!");
		wait1Msec(250);
		//Do nothing but display Driver skills
		break;
		/////////////////////////////////////////////////////////////////
	case 1://If selectProgram = 1, run the code correspoinding with choice PS
		displayLCDCenteredString(0, "Program'n Skills");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);
		resetEncoders();

		//Insert "programming skills (ps) autonomous code here

		stopAllMotors();
		break;
		/////////////////////////////////////////////////////////////////
	case 2://If selectProgram = 2, run the code correspoinding with choice RL
		displayLCDCenteredString(0, "Red Left Auton");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);
		resetEncoders();

		// Insert "Red Right (RR)" autonomous code here

		stopAllMotors();
		break;
		/////////////////////////////////////////////////////////////////
	case 3://If selectProgram = 3, run the code correspoinding with choice RR
		displayLCDCenteredString(0, "Red Right Auton");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);
		resetEncoders();

		// Insert "Red Right (RR)" autonomous code here

		stopAllMotors();
		break;
		/////////////////////////////////////////////////////////////////
	case 4://If selectProgram = 4, run the code correspoinding with choice BL
		displayLCDCenteredString(0, "Blue Left Auton");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);
		resetEncoders();

		// Insert "Blue Left (BL)" autonomous code here

		stopAllMotors();
		break;
		/////////////////////////////////////////////////////////////////
	case 5://If selectProgram = 5, run the code correspoinding with choice BR
		displayLCDCenteredString(0, "Blue Right Auton");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);
		resetEncoders();

		// Insert "Red Right (BR)" autonomous code here

		stopAllMotors();
		break;
		/////////////////////////////////////////////////////////////////
	case 6://If selectProgram = 6, run the code correspoinding with choice Alt
		displayLCDCenteredString(0, "Alternate Auton");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);
		resetEncoders();

		strafeLeft(127,600);

		stopAllMotors();
		break;
		/////////////////////////////////////////////////////////////////
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		wait1Msec(250);
		stopAllMotors();//Stop all Motor
		break;
	}
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
task usercontrol()
{
	startTask(batteryPowerD);//Display Battery Power
	bLCDBacklight = false;//Turn off the backlight for lcd to save battery
	while(true)
	{
		switch(driverC)//Switch between Tank and Arcade
		{
		case 0://Tank Control
			if(vexRT[Btn8R] == 1)//Strafe Right
			{
				motor[frontLeftMotor] = 45;
				motor[backLeftMotor] = -35;
				motor[frontRightMotor] = -45;
				motor[backRightMotor] = 35;
			}
			else if(vexRT[Btn8L] == 1)//Strafe Left
			{
				motor[frontLeftMotor] = -45;
				motor[backLeftMotor] = 35;
				motor[frontRightMotor] = 45;
				motor[backRightMotor] = -35;
			}
			else if(vexRT[Btn8U] == 1)//Move Foward
			{
				motor[frontLeftMotor] = 32;
				motor[backLeftMotor] = 32;
				motor[frontRightMotor] = 32;
				motor[backRightMotor] = 32;
			}
			else if(vexRT[Btn8D] == 1)//Move Backward
			{
				motor[frontLeftMotor] = -32;
				motor[backLeftMotor] = -32;
				motor[frontRightMotor] = -32;
				motor[backRightMotor] = -32;
			}
			else//Tank Drive w/ Deadzone
			{
			motor[frontRightMotor] = abs(vexRT[Ch2]) > deadzone ? vexRT[Ch2] : 0;
			motor[backRightMotor] = abs(vexRT[Ch2]) > deadzone ? vexRT[Ch2] : 0;
			motor[frontLeftMotor] = abs(vexRT[Ch3]) > deadzone ? vexRT[Ch3] : 0;
			motor[backLeftMotor] = abs(vexRT[Ch3]) > deadzone ? vexRT[Ch3] : 0;
			}
			/*+++++++++++++++++++++++++++++++++|Lift System|+++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			if(vexRT[Btn5U] == 1)//lift Up
			{
				if(vexRT[Btn7D] == 1)
				{
					motor[leftLift] = 127;
					motor[rightLift] = 127;
				}
				else if(nMotorEncoder[rightLift] < maxLiftLimit)
				{
					motor[leftLift] = 127;
					motor[rightLift] = 127;
				}
			}
			else if(vexRT[Btn5D] == 1)//lift Down
			{
				if(vexRT[Btn7D] == 1)
				{
					motor[leftLift] = -127;
					motor[rightLift] = -127;
				}
				else if(nMotorEncoder[rightLift] > 0)
				{
					motor[leftLift] = -127;
					motor[rightLift] = -127;
				}
			}
			else //Lift Stay
			{
				motor[leftLift] = 0;
				motor[rightLift] = 0;
			}
			//////////////////////////////////////
			if(vexRT[Btn7U] == 1)//Raise Conveyor Belt
			{
				motor[conveyorMotor] = 127;
			}
			else if(vexRT[Btn7D] == 1)//Lower Conveyor Belt
			{
				motor[conveyorMotor] = -127;
			}
			else
			{
				motor[conveyorMotor] = 0;
			}
			//////////////////////////////////////
			if(vexRT[Btn6D] == 1)//Open claw
			{
				SensorValue[clawPiston] = 0;
			}
			else if(vexRT[Btn6U] == 1) //Closes the claw
			{
				SensorValue[clawPiston] = 1;
			}
			break;
			/////////////////////////////////////////////////////////////////////////////////////////////////////////
		case 1://Arcade Control
			/*++++++++++++++++++++++++++++++++++++++|Drive Robot|+++++++++++++++++++++++++++++++++++++++++++++++*/
		X2 = abs(vexRT[Ch1]) > deadzone ? vexRT[Ch1] : 0;
		Y1 = abs(vexRT[Ch3]) > deadzone ? vexRT[Ch3] : 0;
		X1 = abs(vexRT[Ch4]) > deadzone ? vexRT[Ch4] : 0;
			//--------------------------------------------------------------------
			motor[frontRightMotor] = Y1 - X2 - X1;
			motor[backRightMotor] =  Y1 - X2 + X1;
			motor[frontLeftMotor] = Y1 + X2 + X1;
			motor[backLeftMotor] =  Y1 + X2 - X1;
			/*+++++++++++++++++++++++++++++++++|Lift System|+++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
			if(vexRT[Btn5U] == 1)//lift Up
			{
				if(vexRT[Btn7D] == 1)
				{
					motor[leftLift] = 127;
					motor[rightLift] = 127;
				}
				else if(nMotorEncoder[rightLift] < maxLiftLimit)
				{
					motor[leftLift] = 127;
					motor[rightLift] = 127;
				}
			}
			else if(vexRT[Btn5D] == 1)//lift Down
			{
				if(vexRT[Btn7D] == 1)
				{
					motor[leftLift] = -127;
					motor[rightLift] = -127;
				}
				else if(nMotorEncoder[rightLift] > 0)
				{
					motor[leftLift] = -127;
					motor[rightLift] = -127;
				}
			}
			else //Lift Stay
			{
				motor[leftLift] = 0;
				motor[rightLift] = 0;
			}
				//////////////////////////////////////
			if(vexRT[Btn7U] == 1)//Raise Conveyor Belt
			{
				motor[conveyorMotor] = 127;
			}
			else if(vexRT[Btn7D] == 1)//Lower Conveyor Belt
			{
				motor[conveyorMotor] = -127;
			}
			else
			{
				motor[conveyorMotor] = 0;
			}
			////////////////////////////////////////
			if(vexRT[Btn6D] == 1)//Open claw
			{
				SensorValue[clawPiston] = 0;
			}
			else if(vexRT[Btn6U] == 1) //Closes the claw
			{
				SensorValue[clawPiston] = 1;
			}
			break;
		}
	}
}
